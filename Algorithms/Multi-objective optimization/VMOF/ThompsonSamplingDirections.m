function [Population, Directions] = ThompsonSamplingDirections(Population, Directions, Algorithm, Problem)
%ThompsonSamplingOffspring - Crossover and mutation operators of genetic algorithm.
    %% Parameter setting
    stepGroupNum = 4;
    popFE        = 1000;
    stepFE       = 500;
    stepFEFactor = 0.05;
    stepPopSize  = 25;
    diversityNum = ceil(Problem.N / stepPopSize);
    StartFE      = Problem.FE;
    %% Start the alternating optimisation 
    while Problem.FE - StartFE < stepFEFactor*Problem.maxFE
        %% Sampling directions.
        directions = Directions.sample_directions(Problem.N);
        dirs = directions.dirs();
        steps = directions.steps();
        vels = dirs .* steps;
        
        Population = ControlPopulation(Population, Problem.N);
        Population.adds(vels);
        Population = OptimiseBySMPSO(Algorithm, Problem, Population, popFE);

        %% Selection of diversity solutions
        diversityPop = selectDiversityPop(Population, diversityNum);
        diversityPop = ControlPopulation(diversityPop, diversityNum);
        popGeneratedByDirections   = [];
        sampled_directions = [];

        %% Perform step evolution on each diversity individual
        for c = 1:size(diversityPop,2)
            xPrime                    = diversityPop(c);
            [stepGroup,stepGroupNum]  = GroupDirection(stepGroupNum,xPrime,Problem.D);
            directions                = Directions.sample_directions(stepPopSize).dirs();
            directionOptimizer        = CreateDirectionOptimizer(stepGroupNum, xPrime, stepGroup, Problem, stepPopSize, directions);
            directionPopulation       = CreateInitialDirectionPopulation(directionOptimizer.N, stepGroupNum, directionOptimizer);
            directionPopulation       = OptimiseDirections(directionOptimizer, Problem, directionPopulation, stepFE-stepPopSize);
            diversityStepPop          = selectDiversityPop(directionPopulation, diversityNum);
            tmpPopByStep              = StepGeneratePopulation(directionPopulation, Problem, Population, stepGroup, xPrime, diversityStepPop);
            popGeneratedByDirections  = [popGeneratedByDirections,tmpPopByStep];
%             get complete directions
            group_directions          = max(min(diversityStepPop.decs(),directionOptimizer.upper),directionOptimizer.lower);
            full_directions           = group_directions(directionOptimizer.G);
            sampled_directions        = [sampled_directions; directions .* full_directions];
        end
        
        %% Deal population generated by direction evolution
        Population          = ControlPopulation([Population,popGeneratedByDirections], Problem.N);
        [Population,~,~]    = TS_EnvironmentalSelection(Population,Problem.N);
        Algorithm.NotTerminated(Population);
    end
     %% Optimise until end for uniformity. 
    remainingEvaluations = Problem.maxFE * 0.1;
    Population          = ControlPopulation(Population, Problem.N);

    Population.adds(sampled_directions);
    [Population,~,~]    = TS_EnvironmentalSelection(Population,Problem.N);
    Population          = OptimiseBySMPSO(Algorithm, Problem, Population, remainingEvaluations);
    dirs                = Population.adds();
    if length(Population) < Problem.N
        S = randn(Problem.N - length(Population), Problem.D);
        dp = bsxfun(@rdivide, S, sqrt(sum(S.*S, 2)));
        dirs = [dirs; dp];
    end
    Directions          = DIRECTION(Problem.D, Problem.N, dirs);
end

function stepOptimizer = CreateDirectionOptimizer(gamma, xPrime, G, Global, populationSize, directions)
    stepOptimizer = {};
    stepOptimizer.lower       = zeros(1,gamma);
    stepOptimizer.upper       = ones(1,gamma).*2.0;
    stepOptimizer.N           = populationSize;
    stepOptimizer.xPrime      = xPrime;
    stepOptimizer.G           = G;
    stepOptimizer.xPrimelower = Global.lower;
    stepOptimizer.xPrimeupper = Global.upper;
    stepOptimizer.directions  = directions;
end

function Population = ControlPopulation(input, N)
    [~,ia,~] = unique(input.objs,'rows');
    Population = input(ia);
    theCurrentPopulationSize = size(Population,2);
    if theCurrentPopulationSize < N
        amountToFill    = N-theCurrentPopulationSize;
        FrontNo         = NDSort(input.objs,inf);
        CrowdDis        = CrowdingDistance(input.objs,FrontNo);
        MatingPool      = TournamentSelection(2,amountToFill+1,FrontNo,-CrowdDis);
        Offspring       = OperatorGA(input(MatingPool));
        Population      = [Population,Offspring(1:amountToFill)];
    end
end

function directionPopulation = CreateInitialDirectionPopulation(N, gamma, DirectionOptimizer)
    decs = rand(N,gamma).*2.0;
    directionPopulation = [];
    for i = 1:N
        solution = DirectionIndividual(decs(i,:), DirectionOptimizer, DirectionOptimizer.directions(i,:));
        directionPopulation = [directionPopulation, solution];
    end
end

function diversityPop = selectDiversityPop(input,amount)
    inputSize = size(input,2);
    inFrontNo    = NDSort(input.objs,inf);
    diversityPop = [];
    i = 1;
    if inputSize < amount
        diversityPop = input;
    else
        while size(diversityPop,2) < amount 
            left = amount - size(diversityPop,2);
            theFront = inFrontNo == i;
            newPop = input(theFront);
            FrontNo    = NDSort(newPop.objs,inf);
            CrowdDis   = CrowdingDistance(newPop.objs,FrontNo);
            [~,I] = sort(CrowdDis,'descend');
            until=min(left,size(newPop,2));
            diversityPop = [diversityPop,newPop(I(1:until))];
            i=i+1;
        end
    end
end

function [directioinGroupIndex,numberOfGroups] = GroupDirection(numberOfGroups,diversityPop,numberOfVariables)
    varsPerGroup = floor(numberOfVariables/numberOfGroups);
    vars = diversityPop.dec;
    [~,I] = sort(vars);
    directioinGroupIndex = ones(1,numberOfVariables);
    for i = 1:numberOfGroups-1
       directioinGroupIndex(I(((i-1)*varsPerGroup)+1:i*varsPerGroup)) = i;
    end
    directioinGroupIndex(I(((numberOfGroups-1)*varsPerGroup)+1:end)) = numberOfGroups;
end